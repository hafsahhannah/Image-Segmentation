# -*- coding: utf-8 -*-
"""Image_segmentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g_gwtVtgYC1EOThdk98tTvsCx-ae0PYj
"""

!pip install git+https://github.com/tensorflow/examples.git

#%% #Import packages
import tensorflow as tf
from tensorflow import keras
from IPython.display import clear_output
from tensorflow_examples.models.pix2pix import pix2pix
from tensorflow.keras.callbacks import TensorBoard
from tensorflow.keras import layers,optimizers,losses,callbacks,applications
import numpy as np
import glob
import datetime
import os
import cv2
import matplotlib.pyplot as plt

# Unzip file

#!unzip "/content/data-science-bowl-2018.zip"

#%% 1. Data loading
DATASET_PATH = os.path.join(os.getcwd(), 'data-science-bowl-2018-2')

train_inputs_path = glob.glob(os.path.join(os.getcwd(), DATASET_PATH,'train','inputs','*.png'))
train_masks_path = glob.glob(os.path.join(os.getcwd(), DATASET_PATH,'train','masks','*.png'))
test_inputs_path = glob.glob(os.path.join(os.getcwd(), DATASET_PATH,'test','inputs','*.png'))
test_masks_path = glob.glob(os.path.join(os.getcwd(), DATASET_PATH,'test','masks','*.png'))

#%% 2. Data cleaning and data visualization

IMAGE_SIZE = (128, 128)

train_inputs = [cv2.resize(cv2.cvtColor(cv2.imread(image), cv2.COLOR_BGR2RGB), IMAGE_SIZE) for image in train_inputs_path]
train_masks = [cv2.resize(cv2.imread(mask, cv2.IMREAD_GRAYSCALE), IMAGE_SIZE) for mask in train_masks_path]
test_inputs = [cv2.resize(cv2.cvtColor(cv2.imread(image), cv2.COLOR_BGR2RGB), IMAGE_SIZE) for image in test_inputs_path]
test_masks = [cv2.resize(cv2.imread(mask, cv2.IMREAD_GRAYSCALE), IMAGE_SIZE) for mask in test_masks_path]

# Concert to numpy array

train_inputs_np = np.array(train_inputs)
train_masks_np = np.array(train_masks)
test_inputs_np  = np.array(test_inputs)
test_masks_np = np.array(test_masks)

# Visualize an image example and its corresponding mask from the dataset:

import matplotlib.pyplot as plt
plt.figure(figsize=(10,10))
for i in range(1,4):
    plt.subplot(1,3,i)
    plt.imshow(train_inputs_np[i])
    plt.axis('off')
    
plt.show()

plt.figure(figsize=(10,10))
for i in range(1,4):
    plt.subplot(1,3,i)
    plt.imshow(train_masks_np[i])
    plt.axis('off')
    
plt.show()

#%% 3. Data preparation
# Expand the dimension of masks

train_masks_exp = np.expand_dims(train_masks_np,axis=-1)
test_masks_exp = np.expand_dims(test_masks_np,axis=-1)

# Normalize the images pixels values :D 

train_inputs_norm = train_inputs_np / 255.0
test_inputs_norm = test_inputs_np / 255.0
'''
train_masks_norm = (train_masks_exp > 128) * 1
test_masks_norm = (test_masks_exp > 128) * 1
'''

converted_masks_train = np.round(train_masks_exp /255.0).astype(np.int64)
converted_masks_test = np.round(test_masks_exp /255.0).astype(np.int64)
#Check the mask output

print(np.unique(converted_masks_train[0]))
print(np.unique(converted_masks_test[0]))

#%%
#Normalize image pixels value
converted_inputs_train = train_inputs_np / 255.0
converted_inputs_test = test_inputs_np / 255.0
sample = converted_inputs_train[0]
sample = converted_inputs_test[0]

# Convert numpy array to tensor
'''
train_inputs_tensor = tf.data.Dataset.from_tensor_slices(X_train)
train_masks_tensor = tf.data.Dataset.from_tensor_slices(y_train)
validation_inputs_tensor = tf.data.Dataset.from_tensor_slices(X_val)
validation_masks_tensor = tf.data.Dataset.from_tensor_slices(y_val)
test_inputs_tensor = tf.data.Dataset.from_tensor_slices(test_inputs_norm)
test_masks_tensor = tf.data.Dataset.from_tensor_slices(test_masks_norm)
'''
X_train_tensor = tf.data.Dataset.from_tensor_slices(converted_inputs_train)
X_test_tensor = tf.data.Dataset.from_tensor_slices(converted_inputs_test)
y_train_tensor = tf.data.Dataset.from_tensor_slices(converted_masks_train)
y_test_tensor = tf.data.Dataset.from_tensor_slices(converted_masks_test)

# Combine features and labels together to form a zip dataset
'''
train_dataset = tf.data.Dataset.zip((train_inputs_tensor, train_masks_tensor))
val = tf.data.Dataset.zip((validation_inputs_tensor, validation_masks_tensor))
test_dataset = tf.data.Dataset.zip((test_inputs_tensor, test_masks_tensor))
'''
train_dataset = tf.data.Dataset.zip((X_train_tensor,y_train_tensor))
test_dataset = tf.data.Dataset.zip((X_test_tensor,y_test_tensor))

# Data augmentation

from keras.layers import Layer, RandomZoom, Concatenate, Conv2DTranspose, Input

class Augment(layers.Layer):
    def __init__(self,seed=42):
        super().__init__()
        self.augment_inputs = RandomZoom(0.2, seed=seed)
        self.augment_labels = RandomZoom(0.2, seed=seed)
        
    def call(self,inputs,labels):
        inputs = self.augment_inputs(inputs)
        labels = self.augment_labels(labels)
        return inputs,labels

# Convert to PrefetchDataset

TRAIN_SIZE= len(train_dataset)
BATCH_SIZE = 64
STEPS_PER_EPOCH = TRAIN_SIZE // BATCH_SIZE
BUFFER_SIZE = 1000
AUTOTUNE = tf.data.AUTOTUNE

# Build the input pipeline, applying the augmentation after batching the inputs:

train_pf = (
    train_dataset
    .cache()
    .shuffle(BUFFER_SIZE)
    .batch(BATCH_SIZE)
    .repeat()
    .map(Augment())
    .prefetch(buffer_size=tf.data.AUTOTUNE))


#val_pf = val.batch(BATCH_SIZE)
test_pf = test_dataset.batch(BATCH_SIZE)

for images,masks in train_pf.take(1):
    sample_image, sample_mask = images[0], masks[0]
    display([sample_image, sample_mask])

# Visualize an image example and its corresponding mask from the dataset:

def display(display_list):
  plt.figure(figsize=(15, 15))

  title = ['Input Image', 'True Mask', 'Predicted Mask']

  for i in range(len(display_list)):
    plt.subplot(1, len(display_list), i+1)
    plt.title(title[i])
    plt.imshow(tf.keras.utils.array_to_img(display_list[i]))
    plt.axis('off')
  plt.show()

for images,masks in train_pf.take(1):
    sample_image, sample_mask = images[0], masks[0]
    display([sample_image, sample_mask])

#%% 4. Model develoment

base_model = tf.keras.applications.MobileNetV2(input_shape=[128,128,3],include_top=False)

# Use the activations of these layers
layer_names = [
    'block_1_expand_relu',   # 64x64
    'block_3_expand_relu',   # 32x32
    'block_6_expand_relu',   # 16x16
    'block_13_expand_relu',  # 8x8
    'block_16_project',      # 4x4
]

base_model_outputs = [base_model.get_layer(name).output for name in layer_names]

# Create the feature extraction model

down_stack = tf.keras.Model(inputs=base_model.input, outputs=base_model_outputs)
down_stack.trainable = False

# The decoder/upsampler is simply a series of upsample blocks implemented in TensorFlow examples:

up_stack = [
    pix2pix.upsample(512, 3),  # 4x4 -> 8x8
    pix2pix.upsample(256, 3),  # 8x8 -> 16x16
    pix2pix.upsample(128, 3),  # 16x16 -> 32x32
    pix2pix.upsample(64, 3),   # 32x32 -> 64x64
]

# Build the U-Net model
# Downsampling layers

def unet_model(output_channels:int):
  inputs = tf.keras.layers.Input(shape=[128, 128, 3])

  # Downsampling through the model
  skips = down_stack(inputs)
  x = skips[-1]
  skips = reversed(skips[:-1])

  # Upsampling and establishing the skip connections
  for up, skip in zip(up_stack, skips):
    x = up(x)
    concat = tf.keras.layers.Concatenate()
    x = concat([x, skip])

  # This is the last layer of the model
  last = tf.keras.layers.Conv2DTranspose(
      filters=output_channels, kernel_size=3, strides=2,
      padding='same')  #64x64 -> 128x128

  x = last(x)

  return tf.keras.Model(inputs=inputs, outputs=x)

OUTPUT_CLASSES = 2

model = unet_model(output_channels=OUTPUT_CLASSES)
model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

tf.keras.utils.plot_model(model, show_shapes=True)

model.summary()

# Try out the model to check what it predicts before training:

def create_mask(pred_mask):
  pred_mask = tf.math.argmax(pred_mask, axis=-1)
  pred_mask = pred_mask[..., tf.newaxis]
  return pred_mask[0]

def show_predictions(dataset=None, num=1):
    if dataset:
        for image, mask in dataset.take(num):
            pred_mask = model.predict(image)
            display([image[0], mask[0], create_mask(pred_mask)])
    else:
        display([sample_image, sample_mask, create_mask(model.predict(tf.expand_dims(sample_image, axis=0)))])

display([sample_image,sample_mask,create_mask(model.predict(sample_image[tf.newaxis,...]))])

show_predictions()

# Commented out IPython magic to ensure Python compatibility.
# Tensorboard callback

# %load_ext tensorboard

LOGS_PATH = os.path.join(os.getcwd(),'logs',datetime.datetime.now().strftime('%Y%m%d-%H%M%S'))
ts_callback = TensorBoard(log_dir=LOGS_PATH)

class DisplayCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs=None):
    clear_output(wait=True)
    show_predictions()
    print ('\nSample Prediction after epoch {}\n'.format(epoch+1))

EPOCHS = 5
VAL_SUBSPLITS = 5
VALIDATION_STEPS = len(test_dataset)//BATCH_SIZE//VAL_SUBSPLITS

model_history = model.fit(
    train_pf, 
    validation_data=test_pf, 
    validation_steps=VALIDATION_STEPS, 
    epochs=EPOCHS, 
    steps_per_epoch=STEPS_PER_EPOCH,
    callbacks=[DisplayCallback(), ts_callback]
)

# Commented out IPython magic to ensure Python compatibility.
# %tensorboard --logdir logs

#%% 5. Deploy model

show_predictions(test_pf,3)

#%% 6. Evaluate model

eval = model.evaluate(test_pf)

print(f'Prediction loss: {eval[0]:.2f}')

print(f'Prediction accuracy: {eval[1]:.2f}')

#%% 7. Model saving

model.save('model.h5')